/* tslint:disable */
/* eslint-disable */
/**
 * Dovecord API
 * Backend API for Dovecord
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Channel
 */
export interface Channel {
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof Channel
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    topic?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Channel
     */
    serverId?: string | null;
    /**
     * 
     * @type {Server}
     * @memberof Channel
     */
    server?: Server | null;
    /**
     * 
     * @type {Array<ChannelMessage>}
     * @memberof Channel
     */
    messages?: Array<ChannelMessage> | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof Channel
     */
    recipients?: Array<User> | null;
}
/**
 * 
 * @export
 * @interface ChannelDto
 */
export interface ChannelDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelDto
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof ChannelDto
     */
    type?: number;
    /**
     * 
     * @type {string}
     * @memberof ChannelDto
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelDto
     */
    topic?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelDto
     */
    serverId?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof ChannelDto
     */
    recipients?: Array<User> | null;
}
/**
 * 
 * @export
 * @interface ChannelManipulationDto
 */
export interface ChannelManipulationDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelManipulationDto
     */
    name?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChannelManipulationDto
     */
    type?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelManipulationDto
     */
    topic?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelManipulationDto
     */
    serverId?: string | null;
}
/**
 * 
 * @export
 * @interface ChannelMessage
 */
export interface ChannelMessage {
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    content?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    createdBy?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    createdOn?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelMessage
     */
    isEdit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    lastModifiedOn?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    channelId?: string;
    /**
     * 
     * @type {Channel}
     * @memberof ChannelMessage
     */
    channel?: Channel;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    serverId?: string | null;
    /**
     * 
     * @type {Server}
     * @memberof ChannelMessage
     */
    server?: Server | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessage
     */
    authorId?: string | null;
    /**
     * 
     * @type {User}
     * @memberof ChannelMessage
     */
    author?: User | null;
}
/**
 * 
 * @export
 * @interface ChannelMessageDto
 */
export interface ChannelMessageDto {
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    createdBy?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChannelMessageDto
     */
    isEdit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    lastModifiedOn?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    content?: string | null;
    /**
     * 
     * @type {User}
     * @memberof ChannelMessageDto
     */
    author?: User;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    channelId?: string;
    /**
     * 
     * @type {string}
     * @memberof ChannelMessageDto
     */
    serverId?: string | null;
}
/**
 * 
 * @export
 * @interface MessageManipulationDto
 */
export interface MessageManipulationDto {
    /**
     * 
     * @type {string}
     * @memberof MessageManipulationDto
     */
    content?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageManipulationDto
     */
    channelId?: string;
}
/**
 * 
 * @export
 * @interface Server
 */
export interface Server {
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    iconUrl?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Server
     */
    ownerUserId?: string;
    /**
     * 
     * @type {Array<Channel>}
     * @memberof Server
     */
    channels?: Array<Channel> | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof Server
     */
    members?: Array<User> | null;
}
/**
 * 
 * @export
 * @interface ServerDto
 */
export interface ServerDto {
    /**
     * 
     * @type {string}
     * @memberof ServerDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServerDto
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerDto
     */
    topic?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerDto
     */
    ownerUserId?: string;
    /**
     * 
     * @type {Array<Channel>}
     * @memberof ServerDto
     */
    channels?: Array<Channel> | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof ServerDto
     */
    members?: Array<User> | null;
}
/**
 * 
 * @export
 * @interface ServerManipulationDto
 */
export interface ServerManipulationDto {
    /**
     * 
     * @type {string}
     * @memberof ServerManipulationDto
     */
    name?: string | null;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    isOnline?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    bot?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    system?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    accentColor?: boolean | null;
    /**
     * 
     * @type {Array<Server>}
     * @memberof User
     */
    servers?: Array<Server>;
}
/**
 * 
 * @export
 * @interface UserCreationDto
 */
export interface UserCreationDto {
    /**
     * 
     * @type {string}
     * @memberof UserCreationDto
     */
    name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreationDto
     */
    isOnline?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserDto
 */
export interface UserDto {
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDto
     */
    name?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserDto
     */
    isOnline?: boolean | null;
}
/**
 * 
 * @export
 * @interface UserManipulationDto
 */
export interface UserManipulationDto {
    /**
     * 
     * @type {boolean}
     * @memberof UserManipulationDto
     */
    isOnline?: boolean | null;
}
/**
 * 
 * @export
 * @interface WeatherForecast
 */
export interface WeatherForecast {
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    date?: string;
    /**
     * 
     * @type {number}
     * @memberof WeatherForecast
     */
    temperatureC?: number;
    /**
     * 
     * @type {number}
     * @memberof WeatherForecast
     */
    temperatureF?: number;
    /**
     * 
     * @type {string}
     * @memberof WeatherForecast
     */
    summary?: string | null;
}

/**
 * ChannelApi - axios parameter creator
 * @export
 */
export const ChannelApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAddChannel: async (channelManipulationDto: ChannelManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelManipulationDto' is not null or undefined
            if (channelManipulationDto === null || channelManipulationDto === undefined) {
                throw new RequiredError('channelManipulationDto','Required parameter channelManipulationDto was null or undefined when calling channelAddChannel.');
            }
            const localVarPath = `/api/v1/channels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof channelManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(channelManipulationDto !== undefined ? channelManipulationDto : {})
                : (channelManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDeleteChannel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling channelDeleteChannel.');
            }
            const localVarPath = `/api/v1/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGetChannel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling channelGetChannel.');
            }
            const localVarPath = `/api/v1/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGetChannelMessages: async (channelId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'channelId' is not null or undefined
            if (channelId === null || channelId === undefined) {
                throw new RequiredError('channelId','Required parameter channelId was null or undefined when calling channelGetChannelMessages.');
            }
            const localVarPath = `/api/v1/channels/channels/{channelId}/messages`
                .replace(`{${"channelId"}}`, encodeURIComponent(String(channelId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUpdateChannel: async (id: string, channelManipulationDto: ChannelManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling channelUpdateChannel.');
            }
            // verify required parameter 'channelManipulationDto' is not null or undefined
            if (channelManipulationDto === null || channelManipulationDto === undefined) {
                throw new RequiredError('channelManipulationDto','Required parameter channelManipulationDto was null or undefined when calling channelUpdateChannel.');
            }
            const localVarPath = `/api/v1/channels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof channelManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(channelManipulationDto !== undefined ? channelManipulationDto : {})
                : (channelManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChannelApi - functional programming interface
 * @export
 */
export const ChannelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelAddChannel(channelManipulationDto: ChannelManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelDto>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).channelAddChannel(channelManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelDeleteChannel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).channelDeleteChannel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGetChannel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelDto>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).channelGetChannel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelGetChannelMessages(channelId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelMessageDto>>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).channelGetChannelMessages(channelId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async channelUpdateChannel(id: string, channelManipulationDto: ChannelManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ChannelApiAxiosParamCreator(configuration).channelUpdateChannel(id, channelManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ChannelApi - factory interface
 * @export
 */
export const ChannelApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelAddChannel(channelManipulationDto: ChannelManipulationDto, options?: any): AxiosPromise<ChannelDto> {
            return ChannelApiFp(configuration).channelAddChannel(channelManipulationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelDeleteChannel(id: string, options?: any): AxiosPromise<void> {
            return ChannelApiFp(configuration).channelDeleteChannel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGetChannel(id: string, options?: any): AxiosPromise<ChannelDto> {
            return ChannelApiFp(configuration).channelGetChannel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} channelId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelGetChannelMessages(channelId: string, options?: any): AxiosPromise<Array<ChannelMessageDto>> {
            return ChannelApiFp(configuration).channelGetChannelMessages(channelId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ChannelManipulationDto} channelManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        channelUpdateChannel(id: string, channelManipulationDto: ChannelManipulationDto, options?: any): AxiosPromise<void> {
            return ChannelApiFp(configuration).channelUpdateChannel(id, channelManipulationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChannelApi - object-oriented interface
 * @export
 * @class ChannelApi
 * @extends {BaseAPI}
 */
export class ChannelApi extends BaseAPI {
    /**
     * 
     * @param {ChannelManipulationDto} channelManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelAddChannel(channelManipulationDto: ChannelManipulationDto, options?: any) {
        return ChannelApiFp(this.configuration).channelAddChannel(channelManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelDeleteChannel(id: string, options?: any) {
        return ChannelApiFp(this.configuration).channelDeleteChannel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelGetChannel(id: string, options?: any) {
        return ChannelApiFp(this.configuration).channelGetChannel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} channelId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelGetChannelMessages(channelId: string, options?: any) {
        return ChannelApiFp(this.configuration).channelGetChannelMessages(channelId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ChannelManipulationDto} channelManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChannelApi
     */
    public channelUpdateChannel(id: string, channelManipulationDto: ChannelManipulationDto, options?: any) {
        return ChannelApiFp(this.configuration).channelUpdateChannel(id, channelManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageApi - axios parameter creator
 * @export
 */
export const MessageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageDeleteMessageById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling messageDeleteMessageById.');
            }
            const localVarPath = `/api/v1/messages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageGetMessage: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling messageGetMessage.');
            }
            const localVarPath = `/api/v1/messages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageGetMessagesFromChannel: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling messageGetMessagesFromChannel.');
            }
            const localVarPath = `/api/v1/messages/channel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MessageManipulationDto} messageManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageSaveMessage: async (messageManipulationDto: MessageManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageManipulationDto' is not null or undefined
            if (messageManipulationDto === null || messageManipulationDto === undefined) {
                throw new RequiredError('messageManipulationDto','Required parameter messageManipulationDto was null or undefined when calling messageSaveMessage.');
            }
            const localVarPath = `/api/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof messageManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(messageManipulationDto !== undefined ? messageManipulationDto : {})
                : (messageManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageUpdateMessage: async (id: string, message?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling messageUpdateMessage.');
            }
            const localVarPath = `/api/v1/messages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (message !== undefined) {
                localVarQueryParameter['message'] = message;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageDeleteMessageById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).messageDeleteMessageById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageGetMessage(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMessageDto>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).messageGetMessage(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageGetMessagesFromChannel(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelMessageDto>>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).messageGetMessagesFromChannel(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {MessageManipulationDto} messageManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageSaveMessage(messageManipulationDto: MessageManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChannelMessageDto>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).messageSaveMessage(messageManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messageUpdateMessage(id: string, message?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await MessageApiAxiosParamCreator(configuration).messageUpdateMessage(id, message, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageDeleteMessageById(id: string, options?: any): AxiosPromise<void> {
            return MessageApiFp(configuration).messageDeleteMessageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageGetMessage(id: string, options?: any): AxiosPromise<ChannelMessageDto> {
            return MessageApiFp(configuration).messageGetMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageGetMessagesFromChannel(id: string, options?: any): AxiosPromise<Array<ChannelMessageDto>> {
            return MessageApiFp(configuration).messageGetMessagesFromChannel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MessageManipulationDto} messageManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageSaveMessage(messageManipulationDto: MessageManipulationDto, options?: any): AxiosPromise<ChannelMessageDto> {
            return MessageApiFp(configuration).messageSaveMessage(messageManipulationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [message] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messageUpdateMessage(id: string, message?: string, options?: any): AxiosPromise<void> {
            return MessageApiFp(configuration).messageUpdateMessage(id, message, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageDeleteMessageById(id: string, options?: any) {
        return MessageApiFp(this.configuration).messageDeleteMessageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageGetMessage(id: string, options?: any) {
        return MessageApiFp(this.configuration).messageGetMessage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageGetMessagesFromChannel(id: string, options?: any) {
        return MessageApiFp(this.configuration).messageGetMessagesFromChannel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MessageManipulationDto} messageManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageSaveMessage(messageManipulationDto: MessageManipulationDto, options?: any) {
        return MessageApiFp(this.configuration).messageSaveMessage(messageManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [message] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public messageUpdateMessage(id: string, message?: string, options?: any) {
        return MessageApiFp(this.configuration).messageUpdateMessage(id, message, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverAddServer: async (serverManipulationDto: ServerManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverManipulationDto' is not null or undefined
            if (serverManipulationDto === null || serverManipulationDto === undefined) {
                throw new RequiredError('serverManipulationDto','Required parameter serverManipulationDto was null or undefined when calling serverAddServer.');
            }
            const localVarPath = `/api/v1/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof serverManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(serverManipulationDto !== undefined ? serverManipulationDto : {})
                : (serverManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverDeleteServer: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serverDeleteServer.');
            }
            const localVarPath = `/api/v1/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetChannels: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling serverGetChannels.');
            }
            const localVarPath = `/api/v1/servers/{serverId}/channels`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServerById: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling serverGetServerById.');
            }
            const localVarPath = `/api/v1/servers/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServersOfUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/servers/api/me/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverJoinServer: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling serverJoinServer.');
            }
            const localVarPath = `/api/v1/servers/join/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverLeaveServer: async (serverId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            if (serverId === null || serverId === undefined) {
                throw new RequiredError('serverId','Required parameter serverId was null or undefined when calling serverLeaveServer.');
            }
            const localVarPath = `/api/v1/servers/leave/{serverId}`
                .replace(`{${"serverId"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverUpdateServer: async (id: string, serverManipulationDto: ServerManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling serverUpdateServer.');
            }
            // verify required parameter 'serverManipulationDto' is not null or undefined
            if (serverManipulationDto === null || serverManipulationDto === undefined) {
                throw new RequiredError('serverManipulationDto','Required parameter serverManipulationDto was null or undefined when calling serverUpdateServer.');
            }
            const localVarPath = `/api/v1/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof serverManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(serverManipulationDto !== undefined ? serverManipulationDto : {})
                : (serverManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverAddServer(serverManipulationDto: ServerManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerDto>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverAddServer(serverManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverDeleteServer(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverDeleteServer(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverGetChannels(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChannelDto>>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverGetChannels(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverGetServerById(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerDto>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverGetServerById(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverGetServers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServerDto>>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverGetServers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverGetServersOfUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServerDto>>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverGetServersOfUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverJoinServer(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverJoinServer(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverLeaveServer(serverId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverLeaveServer(serverId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serverUpdateServer(id: string, serverManipulationDto: ServerManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ServerApiAxiosParamCreator(configuration).serverUpdateServer(id, serverManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverAddServer(serverManipulationDto: ServerManipulationDto, options?: any): AxiosPromise<ServerDto> {
            return ServerApiFp(configuration).serverAddServer(serverManipulationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverDeleteServer(id: string, options?: any): AxiosPromise<void> {
            return ServerApiFp(configuration).serverDeleteServer(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetChannels(serverId: string, options?: any): AxiosPromise<Array<ChannelDto>> {
            return ServerApiFp(configuration).serverGetChannels(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServerById(serverId: string, options?: any): AxiosPromise<ServerDto> {
            return ServerApiFp(configuration).serverGetServerById(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServers(options?: any): AxiosPromise<Array<ServerDto>> {
            return ServerApiFp(configuration).serverGetServers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverGetServersOfUser(options?: any): AxiosPromise<Array<ServerDto>> {
            return ServerApiFp(configuration).serverGetServersOfUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverJoinServer(serverId: string, options?: any): AxiosPromise<void> {
            return ServerApiFp(configuration).serverJoinServer(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverLeaveServer(serverId: string, options?: any): AxiosPromise<void> {
            return ServerApiFp(configuration).serverLeaveServer(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {ServerManipulationDto} serverManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverUpdateServer(id: string, serverManipulationDto: ServerManipulationDto, options?: any): AxiosPromise<void> {
            return ServerApiFp(configuration).serverUpdateServer(id, serverManipulationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * 
     * @param {ServerManipulationDto} serverManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverAddServer(serverManipulationDto: ServerManipulationDto, options?: any) {
        return ServerApiFp(this.configuration).serverAddServer(serverManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverDeleteServer(id: string, options?: any) {
        return ServerApiFp(this.configuration).serverDeleteServer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverGetChannels(serverId: string, options?: any) {
        return ServerApiFp(this.configuration).serverGetChannels(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverGetServerById(serverId: string, options?: any) {
        return ServerApiFp(this.configuration).serverGetServerById(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverGetServers(options?: any) {
        return ServerApiFp(this.configuration).serverGetServers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverGetServersOfUser(options?: any) {
        return ServerApiFp(this.configuration).serverGetServersOfUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverJoinServer(serverId: string, options?: any) {
        return ServerApiFp(this.configuration).serverJoinServer(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverLeaveServer(serverId: string, options?: any) {
        return ServerApiFp(this.configuration).serverLeaveServer(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {ServerManipulationDto} serverManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverUpdateServer(id: string, serverManipulationDto: ServerManipulationDto, options?: any) {
        return ServerApiFp(this.configuration).serverUpdateServer(id, serverManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreationDto} userCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddUser: async (userCreationDto: UserCreationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreationDto' is not null or undefined
            if (userCreationDto === null || userCreationDto === undefined) {
                throw new RequiredError('userCreationDto','Required parameter userCreationDto was null or undefined when calling userAddUser.');
            }
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userCreationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userCreationDto !== undefined ? userCreationDto : {})
                : (userCreationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userDeleteUser.');
            }
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userGetUser.');
            }
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserManipulationDto} userManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateUser: async (id: string, userManipulationDto: UserManipulationDto, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling userUpdateUser.');
            }
            // verify required parameter 'userManipulationDto' is not null or undefined
            if (userManipulationDto === null || userManipulationDto === undefined) {
                throw new RequiredError('userManipulationDto','Required parameter userManipulationDto was null or undefined when calling userUpdateUser.');
            }
            const localVarPath = `/api/v1/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof userManipulationDto !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(userManipulationDto !== undefined ? userManipulationDto : {})
                : (userManipulationDto || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UserCreationDto} userCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAddUser(userCreationDto: UserCreationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userAddUser(userCreationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userDeleteUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserDto>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userGetUser(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetUsers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserDto>>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userGetUsers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UserManipulationDto} userManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateUser(id: string, userManipulationDto: UserManipulationDto, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await UserApiAxiosParamCreator(configuration).userUpdateUser(id, userManipulationDto, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {UserCreationDto} userCreationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddUser(userCreationDto: UserCreationDto, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).userAddUser(userCreationDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteUser(id: string, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userDeleteUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUser(id: string, options?: any): AxiosPromise<UserDto> {
            return UserApiFp(configuration).userGetUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetUsers(options?: any): AxiosPromise<Array<UserDto>> {
            return UserApiFp(configuration).userGetUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UserManipulationDto} userManipulationDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateUser(id: string, userManipulationDto: UserManipulationDto, options?: any): AxiosPromise<void> {
            return UserApiFp(configuration).userUpdateUser(id, userManipulationDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @param {UserCreationDto} userCreationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAddUser(userCreationDto: UserCreationDto, options?: any) {
        return UserApiFp(this.configuration).userAddUser(userCreationDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteUser(id: string, options?: any) {
        return UserApiFp(this.configuration).userDeleteUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetUser(id: string, options?: any) {
        return UserApiFp(this.configuration).userGetUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetUsers(options?: any) {
        return UserApiFp(this.configuration).userGetUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UserManipulationDto} userManipulationDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateUser(id: string, userManipulationDto: UserManipulationDto, options?: any) {
        return UserApiFp(this.configuration).userUpdateUser(id, userManipulationDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WeatherForecastApi - axios parameter creator
 * @export
 */
export const WeatherForecastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [apiVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weatherForecastGet: async (apiVersion?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/weatherforecast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken("bearer", [])
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (apiVersion !== undefined) {
                localVarQueryParameter['api-version'] = apiVersion;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WeatherForecastApi - functional programming interface
 * @export
 */
export const WeatherForecastApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [apiVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async weatherForecastGet(apiVersion?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WeatherForecast>>> {
            const localVarAxiosArgs = await WeatherForecastApiAxiosParamCreator(configuration).weatherForecastGet(apiVersion, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WeatherForecastApi - factory interface
 * @export
 */
export const WeatherForecastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {string} [apiVersion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        weatherForecastGet(apiVersion?: string, options?: any): AxiosPromise<Array<WeatherForecast>> {
            return WeatherForecastApiFp(configuration).weatherForecastGet(apiVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WeatherForecastApi - object-oriented interface
 * @export
 * @class WeatherForecastApi
 * @extends {BaseAPI}
 */
export class WeatherForecastApi extends BaseAPI {
    /**
     * 
     * @param {string} [apiVersion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WeatherForecastApi
     */
    public weatherForecastGet(apiVersion?: string, options?: any) {
        return WeatherForecastApiFp(this.configuration).weatherForecastGet(apiVersion, options).then((request) => request(this.axios, this.basePath));
    }
}


